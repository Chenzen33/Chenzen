do local Rayfield=loadstring(game:HttpGet("https://sirius.menu/rayfield"))();local Window=Rayfield:CreateWindow({Name="EASTERN WAR HUB",Icon=0,LoadingTitle="CHEN",LoadingSubtitle="by CHEN",Theme="Dark Blue",DisableRayfieldPrompts=false,DisableBuildWarnings=false,ConfigurationSaving={Enabled=true,FolderName=nil,FileName="Big Hub"},Discord={Enabled=false,Invite="noinvitelink",RememberJoins=true},KeySystem=true,KeySettings={Title="Untitled",Subtitle="Key System",Note="No method of obtaining the key is provided",FileName="Key",SaveKey=true,GrabKeyFromSite=false,Key={"."}}});local Tab=Window:CreateTab("Menu",4483362458);local Slider=Tab:CreateSlider({Name="Speed",Range={0,200},Increment=10,Suffix="Speed",CurrentValue=10,Flag="Slider1",Callback=function(Value) game.Players.LocalPlayer.Character.Humanoid.WalkSpeed=Valu;end});local Players=game:GetService("Players");local function getPlayerNames() local playerList={};for _,player in pairs(Players:GetPlayers()) do if (player~=Players.LocalPlayer) then table.insert(playerList,player.Name);end end return playerList;end local Dropdown=Tab:CreateDropdown({Name="TP to Player",Options=getPlayerNames(),CurrentOption={},MultipleOptions=false,Flag="Dropdown1",Callback=function(Selected) local targetPlayer=Players:FindFirstChild(Selected[1]);if (targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart")) then local localPlayer=Players.LocalPlayer;if (localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")) then localPlayer.Character.HumanoidRootPart.CFrame=targetPlayer.Character.HumanoidRootPart.CFrame + Vector3.new(0,3,0) ;end end end});Players.PlayerAdded:Connect(function() Dropdown:SetOptions(getPlayerNames());end);Players.PlayerRemoving:Connect(function() Dropdown:SetOptions(getPlayerNames());end);local Players=game:GetService("Players");local RunService=game:GetService("RunService");local UserInputService=game:GetService("UserInputService");local player=Players.LocalPlayer;local camera=workspace.CurrentCamera;local aimKey=Enum.UserInputType.MouseButton2;local aimSmoothing=0.12;local aimFOV=150;local isAiming=false;local autoAimEnabled=false;local noRecoilEnabled=false;local Toggle=Tab:CreateToggle({Name="AUTO AIM NO RECOIL",CurrentValue=false,Flag="Toggle1",Callback=function(Value) autoAimEnabled=Value;noRecoilEnabled=Value;end});UserInputService.InputBegan:Connect(function(input,gameProcessed) if (input.UserInputType==aimKey) then isAiming=true;end end);UserInputService.InputEnded:Connect(function(input,gameProcessed) if (input.UserInputType==aimKey) then isAiming=false;end end);local function getClosestEnemy() local closestEnemy=nil;local shortestDistance=aimFOV;for _,target in pairs(Players:GetPlayers()) do if ((target~=player) and (target.Team~=player.Team)) then local character=target.Character;if (character and character:FindFirstChild("HumanoidRootPart") and character:FindFirstChild("Head")) then local headPos=camera:WorldToViewportPoint(character.Head.Position);local enemyPos=camera:WorldToViewportPoint(character.HumanoidRootPart.Position);local distance=(Vector2.new(enemyPos.X,enemyPos.Y) -Vector2.new(camera.ViewportSize.X/2 ,camera.ViewportSize.Y/2 )).Magnitude;if (distance<shortestDistance) then shortestDistance=distance;closestEnemy=character.Head;end end end end return closestEnemy;end RunService.RenderStepped:Connect(function() if (autoAimEnabled and isAiming) then local target=getClosestEnemy();if target then local targetPos=camera:WorldToViewportPoint(target.Position);local smoothX=(targetPos.X-(camera.ViewportSize.X/2)) * aimSmoothing ;local smoothY=(targetPos.Y-(camera.ViewportSize.Y/2)) * aimSmoothing ;mousemoverel(smoothX,smoothY);end end end);local function removeRecoil(weapon) if noRecoilEnabled then for _,v in pairs(weapon:GetDescendants()) do if (v:IsA("NumberValue") and v.Name:lower():find("recoil")) then v.Value=0;elseif (v:IsA("BodyVelocity") or v:IsA("BodyGyro")) then v:Destroy();end end end end local Players=game:GetService("Players");local RunService=game:GetService("RunService");local LocalPlayer=Players.LocalPlayer;local ESPEnabled=false;local ESPObjects={};local function CreateESP(player) if ((player==LocalPlayer) or ESPObjects[player]) then return;end local character=player.Character or player.CharacterAdded:Wait() ;if  not character then return;end local espGui=Instance.new("BillboardGui",character);espGui.Name="ESP";espGui.Size=UDim2.new(0,200,0,50);espGui.StudsOffset=Vector3.new(0,2,0);espGui.AlwaysOnTop=true;local nameTag=Instance.new("TextLabel",espGui);nameTag.Size=UDim2.new(1,0,1,0);nameTag.BackgroundTransparency=1;nameTag.TextStrokeTransparency=0.5;nameTag.TextScaled=true;nameTag.Font=Enum.Font.SourceSansBold;local highlight=Instance.new("Highlight",character);highlight.DepthMode=Enum.HighlightDepthMode.AlwaysOnTop;ESPObjects[player]={espGui=espGui,highlight=highlight};local function UpdateESP() if ( not ESPEnabled or  not character or  not character:FindFirstChild("HumanoidRootPart")) then espGui.Enabled=false;highlight.Enabled=false;return;end local humanoid=character:FindFirstChild("Humanoid");if humanoid then local distance=math.floor((LocalPlayer.Character.HumanoidRootPart.Position-character.HumanoidRootPart.Position).Magnitude);local health=math.floor(humanoid.Health);nameTag.Text=string.format("%s | %d HP | %d studs",player.Name,health,distance);local isFriendly=player.Team==LocalPlayer.Team ;nameTag.TextColor3=(isFriendly and Color3.fromRGB(0,255,0)) or Color3.fromRGB(255,0,0) ;highlight.FillColor=(isFriendly and Color3.fromRGB(0,255,0)) or Color3.fromRGB(255,0,0) ;highlight.OutlineColor=Color3.fromRGB(0,0,0);espGui.Enabled=true;highlight.Enabled=true;end end RunService.RenderStepped:Connect(UpdateESP);end local function RemoveESP(player) if ESPObjects[player] then ESPObjects[player].espGui:Destroy();ESPObjects[player].highlight:Destroy();ESPObjects[player]=nil;end end for _,player in pairs(Players:GetPlayers()) do if ESPEnabled then CreateESP(player);end end Players.PlayerAdded:Connect(function(player) player.CharacterAdded:Connect(function() if ESPEnabled then CreateESP(player);end end);end);local ToggleESP=Tab:CreateToggle({Name="ESP",CurrentValue=false,Flag="Toggle1",Callback=function(Value) ESPEnabled=Value;if ESPEnabled then for _,player in pairs(Players:GetPlayers()) do CreateESP(player);end else for _,player in pairs(ESPObjects) do RemoveESP(player);end end end});local players=game:GetService("Players");local localPlayer=players.LocalPlayer;local markers={};local function cleanupMarkers() for _,marker in ipairs(markers) do if (marker and marker.Parent) then marker:Destroy();end end markers={};end local function traceAllPlayers() cleanupMarkers();for _,player in ipairs(players:GetPlayers()) do if (player==localPlayer) then continue;end local character=player.Character;if (character and character:FindFirstChild("HumanoidRootPart")) then local position=character.HumanoidRootPart.Position;local marker=Instance.new("Part");marker.Shape=Enum.PartType.Ball;marker.Size=Vector3.new(1,1,1);marker.Position=position;marker.Anchored=true;marker.CanCollide=false;if (player.Team==localPlayer.Team) then marker.Color=Color3.fromRGB(0,255,0);print(player.Name   .. " is a teammate (Green)" );else marker.Color=Color3.fromRGB(255,0,0);print(player.Name   .. " is an enemy (Red)" );end marker.Parent=workspace;table.insert(markers,marker);end end end local Players=game:GetService("Players");local RunService=game:GetService("RunService");local localPlayer=Players.LocalPlayer;local beams={};local isTracing=false;local function cleanupBeams() for _,beamData in pairs(beams) do if (beamData.beam and beamData.beam.Parent) then beamData.beam:Destroy();end if (beamData.attachment0 and beamData.attachment0.Parent) then beamData.attachment0:Destroy();end if (beamData.attachment1 and beamData.attachment1.Parent) then beamData.attachment1:Destroy();end end beams={};end local function updateTracers() while isTracing do cleanupBeams();for _,player in ipairs(Players:GetPlayers()) do if ((player~=localPlayer) and player.Character and player.Character:FindFirstChild("HumanoidRootPart")) then local targetRoot=player.Character.HumanoidRootPart;local localRoot=localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") ;if localRoot then local attachment0=Instance.new("Attachment");attachment0.Position=Vector3.new(0, -1.5,0);attachment0.Parent=localRoot;local attachment1=Instance.new("Attachment");attachment1.Position=Vector3.new(0, -1.5,0);attachment1.Parent=targetRoot;local beam=Instance.new("Beam");beam.Attachment0=attachment0;beam.Attachment1=attachment1;beam.Width0=0.08;beam.Width1=0.08;beam.LightEmission=1;beam.LightInfluence=0;beam.Segments=10;beam.Texture="rbxassetid://2924025";beam.TextureLength=1;beam.TextureSpeed=0.5;beam.Parent=workspace;if (player.Team==localPlayer.Team) then beam.Color=ColorSequence.new(Color3.fromRGB(0,255,0));else beam.Color=ColorSequence.new(Color3.fromRGB(255,0,0));end beams[player]={beam=beam,attachment0=attachment0,attachment1=attachment1};end end end RunService.RenderStepped:Wait();end end local Toggle=Tab:CreateToggle({Name="Tracer",CurrentValue=false,Flag="Toggle1",Callback=function(Value) if Value then isTracing=true;print("Tracer ON");updateTracers();else isTracing=false;print("Tracer OFF");cleanupBeams();end end});local xrayEnabled=false;local Toggle=Tab:CreateToggle({Name="X-Ray Vision",CurrentValue=false,Flag="XRayToggle",Callback=function(value) xrayEnabled=value;for _,v in pairs(workspace:GetDescendants()) do if (v:IsA("BasePart") and  not v:IsDescendantOf(game.Players) and  not v.Parent:FindFirstChildOfClass("Humanoid")) then v.Transparency=(xrayEnabled and 0.7) or 0 ;end end end});local CrosshairEnabled=false;local CrosshairLines={};local function CreateCrosshair() CrosshairLines.Horizontal=Drawing.new("Line");CrosshairLines.Vertical=Drawing.new("Line");for _,line in pairs(CrosshairLines) do line.Visible=false;line.Color=Color3.fromRGB(0,255,0);line.Thickness=2;line.Transparency=1;end end local function UpdateCrosshair() if  not CrosshairEnabled then return;end local screenSize=workspace.CurrentCamera.ViewportSize;local centerX,centerY=screenSize.X/2 ,screenSize.Y/2 ;local size=10;CrosshairLines.Horizontal.From=Vector2.new(centerX-size ,centerY);CrosshairLines.Horizontal.To=Vector2.new(centerX + size ,centerY);CrosshairLines.Horizontal.Visible=true;CrosshairLines.Vertical.From=Vector2.new(centerX,centerY-size );CrosshairLines.Vertical.To=Vector2.new(centerX,centerY + size );CrosshairLines.Vertical.Visible=true;end local function ToggleCrosshair(Value) CrosshairEnabled=Value;if CrosshairEnabled then UpdateCrosshair();else for _,line in pairs(CrosshairLines) do line.Visible=false;end end end CreateCrosshair();local Toggle=Tab:CreateToggle({Name="Crossfire",CurrentValue=false,Flag="Toggle1",Callback=function(Value) ToggleCrosshair(Value);end});local player=game.Players.LocalPlayer;local character=player.Character or player.CharacterAdded:Wait() ;local humanoid=character:WaitForChild("Humanoid");local autoHeal=false;local function startHealing() while autoHeal do if (humanoid and (humanoid.Health>0) and (humanoid.Health<humanoid.MaxHealth)) then humanoid.Health=math.min(humanoid.Health + 10 ,humanoid.MaxHealth);end wait(1);end end local function stopHealing() autoHeal=false;end local Toggle=Tab:CreateToggle({Name="Auto Heal",CurrentValue=false,Flag="AutoHealToggle",Callback=function(Value) autoHeal=Value;if autoHeal then startHealing();else stopHealing();end end});humanoid.Died:Connect(function() stopHealing();end);player.CharacterAdded:Connect(function(newCharacter) character=newCharacter;humanoid=character:WaitForChild("Humanoid");if autoHeal then startHealing();end end);if autoHeal then startHealing();end local Button=Tab:CreateButton({Name="Heal Now (Manual)",Callback=function() local player=game.Players.LocalPlayer;if (player and player.Character and player.Character:FindFirstChild("Humanoid")) then player.Character.Humanoid.Health=player.Character.Humanoid.MaxHealth;end end});local Button=Tab:CreateButton({Name="Auto Rejoin",Callback=function() while true do wait(2);game:GetService("TeleportService"):Teleport(game.PlaceId);end end});Rayfield:LoadConfiguration(); end
